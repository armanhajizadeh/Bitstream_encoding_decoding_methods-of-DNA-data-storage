# -*- coding: utf-8 -*-
"""bitstreaming/encoding-decoding with identifier.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G2S1YxrdIZTurnPU0OMKwiLjUZrHy3yZ
"""

encoding_map = {
    '00': '001',
    '01': '011',
    '10': '100',
    '11': '110'
}

decoding_map = {v: k for k, v in encoding_map.items()}

char_to_bin6 = {
    'A': '011000', 'B': '010100', 'C': '101111', 'D': '111110',
    'E': '101001', 'F': '101011', 'G': '111111', 'H': '011001',
    'I': '001110', 'J': '001011', 'K': '000010', 'L': '111001',
    'M': '110101', 'N': '110111', 'O': '101000', 'P': '101110',
    'Q': '000001', 'R': '110100', 'S': '000101', 'T': '111101',
    'U': '011110', 'V': '010111', 'W': '010110', 'X': '011100',
    'Y': '000000', 'Z': '011111', '0': '000111', '1': '000110',
    '2': '110010', '3': '100100', '4': '100010', '5': '001000',
    '6': '111100', '7': '000100', '8': '001010', '9': '100110',
    ' ': '001100', ',': '110110', '.': '100011', '?': '100111',

    '!': '001001', '"': '001101', '#': '001111', '$': '010000',
    '%': '010001', '&': '010010', "'": '010011', '(': '011010',
    ')': '011011', '*': '100000', '+': '100001', '-': '100101',
    '/': '101010', ':': '101100', ';': '101101', '<': '110000',
    '=': '110001', '>': '110011', '@': '111000', '[': '111010',
    '\\': '111011', ']': '010101',
    '^': '011101',
    '_': '000011'
}

# Create reverse mapping for decoding
bin6_to_char = {v: k for k, v in char_to_bin6.items()}

binary_to_dna = {
    '00': 'A',
    '01': 'C',
    '10': 'T',
    '11': 'G'
}

# Create reverse mapping for decoding
dna_to_binary = {v: k for k, v in binary_to_dna.items()}

def encode_6bit(bitstream: str) -> str:
    """
    Encodes a 6-bit binary string using the 2-to-3 bit mapping.
    Then appends a '0' as a padding bit, so the final output is 10 bits.
    """
    if len(bitstream) != 6:
        raise ValueError("Input bitstream must be exactly 6 bits.")

    encoded = ''
    for i in range(0, 6, 2):
        pair = bitstream[i:i+2]
        encoded += encoding_map[pair]

    # Always append '0' as padding
    return encoded + '0'

def decode_10bit(encoded_bits: str) -> str:
    """
    Decodes a 10-bit encoded string back to a 6-bit binary string.
    The last bit is discarded as it's just padding.
    """
    if len(encoded_bits) != 10:
        raise ValueError("Encoded bitstream must be exactly 10 bits.")

    # Discard the padding bit (last bit)
    encoded_9bit = encoded_bits[:9]

    if len(encoded_9bit) != 9:
        raise ValueError("After removing padding, encoded bitstream must be 9 bits.")

    decoded = ''
    for i in range(0, 9, 3):
        triplet = encoded_9bit[i:i+3]
        if triplet not in decoding_map:
            raise ValueError(f"Invalid encoded triplet: {triplet}")
        decoded += decoding_map[triplet]

    return decoded

def binary_to_actg(binary_str: str) -> str:
    """
    Converts an even-length binary string into ACTG format by grouping
    each 2-bit segment and mapping via binary_to_dna.
    """
    if len(binary_str) % 2 != 0:
        raise ValueError("Binary string length must be even for ACTG conversion.")

    dna = ''
    for i in range(0, len(binary_str), 2):
        pair = binary_str[i:i+2]
        dna += binary_to_dna[pair]
    return dna

def actg_to_binary(dna_str: str) -> str:
    """
    Converts an ACTG string back to binary by mapping each nucleotide
    to its corresponding 2-bit representation.
    """
    binary = ''
    for nucleotide in dna_str:
        if nucleotide not in dna_to_binary:
            raise ValueError(f"Invalid nucleotide: {nucleotide}")
        binary += dna_to_binary[nucleotide]
    return binary

# ---------- Encoding Pipeline ----------
def text_to_actg_dna(text: str) -> str:
    """
    Converts the provided text into an ACTG DNA string by:
      1. Converting each character to its 6-bit code.
      2. Mapping the 6 bits to a 9-bit encoded binary string via encoding_map.
      3. Appending a '0' padding bit (resulting in 10 bits per character).
      4. Converting the 10-bit binary string to an ACTG string.
    """
    text = text.upper()
    dna_output = ''
    for char in text:
        if char not in char_to_bin6:
            raise ValueError(f"Unsupported character: {char}")
        # Convert character into its 6-bit binary representation.
        binary = char_to_bin6[char]
        # Encode into 9 bits then append a '0' (always)
        encoded_binary = encode_6bit(binary)
        # Convert the 10-bit binary string into ACTG format.
        dna = binary_to_actg(encoded_binary)
        dna_output += dna
    return dna_output

# ---------- Decoding Pipeline ----------
def actg_dna_to_text(dna_str: str) -> str:
    """
    Converts an ACTG DNA string back to the original text by:
      1. Converting each nucleotide to its 2-bit binary representation.
      2. Grouping into chunks of 10 bits (representing one character).
      3. Decoding the 10-bit chunks back to 6-bit using the decoding map.
      4. Converting the 6-bit binary back to the original character.
    """
    if len(dna_str) % 5 != 0:
        raise ValueError("DNA string length must be a multiple of 5 for decoding.")

    binary_str = actg_to_binary(dna_str)

    text_output = ''
    for i in range(0, len(binary_str), 10):
        chunk = binary_str[i:i+10]
        if len(chunk) != 10:
            raise ValueError(f"Incomplete chunk at position {i}: {chunk}")

        # Decode the 10-bit chunk back to 6-bit
        decoded_6bit = decode_10bit(chunk)

        # Convert 6-bit back to character
        if decoded_6bit not in bin6_to_char:
            raise ValueError(f"Invalid decoded 6-bit sequence: {decoded_6bit}")

        char = bin6_to_char[decoded_6bit]
        text_output += char

    return text_output

# ---------- GC Content and Chunk Analysis Functions ----------
def gc_content(seq: str) -> float:
    """
    Computes the GC content percentage of the given DNA sequence.
    """
    if len(seq) == 0:
        return 0.0
    gc_count = seq.count('G') + seq.count('C')
    return (gc_count / len(seq)) * 100.0

def flip_sequence(seq: str) -> str:
    """
    Flips a DNA sequence by swapping:
      - A <--> C
      - T <--> G
    """
    mapping = {'A': 'C', 'C': 'A', 'T': 'G', 'G': 'T'}
    return ''.join(mapping.get(nuc, nuc) for nuc in seq)

def split_into_chunks(seq: str, chunk_size: int) -> list:
    """
    Splits a string into a list of strings, each of length chunk_size.
    The final chunk may be shorter if there is remaining sequence.
    """
    return [seq[i:i+chunk_size] for i in range(0, len(seq), chunk_size)]

def modify_chunk(chunk: str) -> (str, str, float):
    """
    Processes a 30-nt chunk as follows:
      - Compute overall GC content.
      - If GC is between 25 and 75, leave the chunk unchanged and assign identifier "CAG".
      - If overall GC > 75, split into two halves (15 nt each), flip the half with higher GC,
        and assign identifier "CGA".
      - If overall GC < 25, split into two halves, flip the half with lower GC, and assign identifier "ACG".
    Returns a tuple: (modified_chunk_with_identifier, identifier, new_GC_content)
    where new_GC_content is computed on the modified 30-nt sequence (before appending the identifier).
    """
    overall_gc = gc_content(chunk)
    if len(chunk) != 30:
        # For chunks less than 30 nt, return unchanged.
        return (chunk, "", overall_gc)

    if 25 <= overall_gc <= 75:
        modified = chunk  # unchanged
        identifier = "CAG"
    elif overall_gc > 75:
        first_half = chunk[:15]
        second_half = chunk[15:]
        gc1 = gc_content(first_half)
        gc2 = gc_content(second_half)
        if gc1 >= gc2:
            flipped_half = flip_sequence(first_half)
            modified = flipped_half + second_half
        else:
            flipped_half = flip_sequence(second_half)
            modified = first_half + flipped_half
        identifier = "CGA"
    else:  # overall_gc < 25
        first_half = chunk[:15]
        second_half = chunk[15:]
        gc1 = gc_content(first_half)
        gc2 = gc_content(second_half)
        if gc1 <= gc2:
            flipped_half = flip_sequence(first_half)
            modified = flipped_half + second_half
        else:
            flipped_half = flip_sequence(second_half)
            modified = first_half + flipped_half
        identifier = "ACG"

    new_gc = gc_content(modified)
    # Append the identifier after the 30-nt chunk.
    return (modified + identifier, identifier, new_gc)

# ---------- Triple Nucleotide Check Function ----------
def check_triple_nucleotides(seq: str) -> dict:
    """
    Checks a DNA sequence for the presence of triple nucleotides (AAA, CCC, TTT, GGG).
    Returns a dictionary with counts and positions of each triple nucleotide.
    """
    result = {}
    patterns = ['AAA', 'CCC', 'TTT', 'GGG']

    for pattern in patterns:
        # Find all occurrences of the pattern
        occurrences = []
        start_pos = 0

        while True:
            pos = seq.find(pattern, start_pos)
            if pos == -1:
                break
            occurrences.append(pos)
            start_pos = pos + 1  # Overlap allowed

        result[pattern] = {
            'count': len(occurrences),
            'positions': occurrences
        }

    # Calculate total number of triple nucleotides
    result['total_count'] = sum(result[pattern]['count'] for pattern in patterns)

    return result

# ---------- Reverse Modifications Function ----------
def reverse_modifications(modified_actg: str) -> str:
    """
    Reverses the modifications made to chunks during encoding:
      1. Recognizes the identifiers (CAG, CGA, ACG) and removes them.
      2. For CGA chunks, identifies and flips the modified half.
      3. For ACG chunks, identifies and flips the modified half.
      4. Returns the original ACTG sequence.
    """
    chunks = []
    i = 0

    while i < len(modified_actg):
        # Check if we have a full chunk (33 characters = 30 nucleotides + 3 character identifier)
        if i + 33 <= len(modified_actg):
            chunk = modified_actg[i:i+30]
            identifier = modified_actg[i+30:i+33]

            if identifier == "CAG":
                # No modifications needed, just keep the chunk
                chunks.append(chunk)
            elif identifier == "CGA":
                # High GC content chunk, need to reverse the flip
                # We need to identify which half was flipped based on GC content
                first_half = chunk[:15]
                second_half = chunk[15:]
                gc1 = gc_content(first_half)
                gc2 = gc_content(second_half)

                # The half with lower GC content was likely flipped (since flipping reduces GC content)
                if gc1 <= gc2:
                    flipped_half = flip_sequence(first_half)
                    restored_chunk = flipped_half + second_half
                else:
                    flipped_half = flip_sequence(second_half)
                    restored_chunk = first_half + flipped_half
                chunks.append(restored_chunk)
            elif identifier == "ACG":
                # Low GC content chunk, need to reverse the flip
                # We need to identify which half was flipped based on GC content
                first_half = chunk[:15]
                second_half = chunk[15:]
                gc1 = gc_content(first_half)
                gc2 = gc_content(second_half)

                # The half with higher GC content was likely flipped (since flipping increases GC content)
                if gc1 >= gc2:
                    flipped_half = flip_sequence(first_half)
                    restored_chunk = flipped_half + second_half
                else:
                    flipped_half = flip_sequence(second_half)
                    restored_chunk = first_half + flipped_half
                chunks.append(restored_chunk)
            else:
                # Unrecognized identifier or no identifier, treat as a normal chunk
                chunks.append(modified_actg[i:i+33])

            i += 33  # Move past this chunk and its identifier
        else:
            # Last partial chunk without an identifier
            chunks.append(modified_actg[i:])
            break

    return ''.join(chunks)

# ---------- Main Analysis Pipeline ----------
if __name__ == "__main__":
    # Example input text; change as needed.
    input_text = "Arman is awesome? not yet. (just kiddin!)"
    print(f"Original input text: '{input_text}'")

    # Convert text to ACTG DNA (original output without chunk modifications)
    original_actg = text_to_actg_dna(input_text)
    original_gc = gc_content(original_actg)
    print("\n=== ORIGINAL ACTG (without identifiers) ===")
    print(original_actg)
    print(f"Overall GC Content: {original_gc:.2f}%")
    print()

    # Split the ACTG string into chunks of 30 nucleotides.
    chunks = split_into_chunks(original_actg, 30)

    modified_chunks = []
    print("=== Chunk Analysis and Modification ===")
    for idx, chunk in enumerate(chunks, start=1):
        original_gc = gc_content(chunk)
        if len(chunk) < 30:
            print(f"Chunk {idx} (length {len(chunk)}): {chunk}")
            print(f"  Original GC: {original_gc:.2f}% (unchanged)")
            modified_chunks.append(chunk)
        else:
            mod_chunk, identifier, new_gc = modify_chunk(chunk)
            print(f"Chunk {idx}:")
            print(f"  Original: {chunk}")
            print(f"    Overall GC: {original_gc:.2f}%")
            print(f"  Modified: {mod_chunk} (Identifier: {identifier})")
            print(f"    New GC: {new_gc:.2f}%")
            modified_chunks.append(mod_chunk)

    # Recombine the modified chunks.
    modified_actg = ''.join(modified_chunks)
    modified_gc = gc_content(modified_actg)

    # Calculate GC content excluding the identifiers (CAG, CGA, ACG)
    # First, let's identify and remove the identifiers
    modified_actg_no_identifiers = ""
    i = 0
    while i < len(modified_actg):
        if i + 33 <= len(modified_actg) and (
            modified_actg[i+30:i+33] == "CAG" or
            modified_actg[i+30:i+33] == "CGA" or
            modified_actg[i+30:i+33] == "ACG"
        ):
            modified_actg_no_identifiers += modified_actg[i:i+30]
            i += 33  # Skip the 30 nucleotides + 3 identifier letters
        else:
            modified_actg_no_identifiers += modified_actg[i]
            i += 1

    modified_gc_no_identifiers = gc_content(modified_actg_no_identifiers)

    print("\n=== FINAL OUTPUT ===")
    print("ACTG without identifiers:")
    print(original_actg)
    print(f"GC Content: {original_gc:.2f}%")

    print("\nACTG with modifications and identifiers:")
    print(modified_actg)
    print(f"GC Content (including identifiers): {modified_gc:.2f}%")
    print(f"GC Content (excluding identifiers): {modified_gc_no_identifiers:.2f}%")

    # Check for triple nucleotides in the modified sequence
    print("\n=== TRIPLE NUCLEOTIDE CHECK ===")
    triple_check = check_triple_nucleotides(modified_actg)

    print(f"Total triple nucleotides found: {triple_check['total_count']}")
    for pattern in ['AAA', 'CCC', 'TTT', 'GGG']:
        count = triple_check[pattern]['count']
        if count > 0:
            positions = triple_check[pattern]['positions']
            print(f"- {pattern}: {count} occurrences at positions {positions}")
        else:
            print(f"- {pattern}: No occurrences")

    # ===== Decoding Process =====
    print("\n=== DECODING PROCESS ===")

    # Step 1: Reverse the chunk modifications
    print("Step 1: Reversing chunk modifications...")
    reversed_modifications = reverse_modifications(modified_actg)
    print(f"Reversed modifications: {reversed_modifications}")
    print(f"Original ACTG: {original_actg}")
    print(f"Are they identical? {reversed_modifications == original_actg}")

    # Step 2: Convert the ACTG back to text
    print("\nStep 2: Converting ACTG back to text...")
    decoded_text = actg_dna_to_text(original_actg)
    print(f"Decoded text: '{decoded_text}'")
    print(f"Original text: '{input_text}'")
    # Use case-insensitive comparison
    print(f"Are they identical (case-insensitive)? {decoded_text.upper() == input_text.upper()}")

    # Full decoding pipeline from modified ACTG to text
    print("\n=== FULL DECODING PIPELINE ===")
    try:
        # First reverse the modifications
        reversed_actg = reverse_modifications(modified_actg)
        # Then convert back to text
        final_decoded_text = actg_dna_to_text(reversed_actg)
        print(f"Original text: '{input_text}'")
        print(f"Decoded text: '{final_decoded_text}'")
        # Use case-insensitive comparison
        print(f"Successful decoding (case-insensitive): {final_decoded_text.upper() == input_text.upper()}")
    except Exception as e:
        print(f"Error during decoding: {e}")